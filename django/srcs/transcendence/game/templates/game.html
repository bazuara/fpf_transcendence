<div id="canvasContainer">
	<canvas id="backgroundPongCanvas"> </canvas> 
	<canvas id="pongCanvas"> </canvas>
</div>
<script>

    async function waitPathname() {
        while (window.location.pathname.startsWith("/rooms"))
            await setTimeout(()=>{}, 1)
    }

	async function start() {
		await waitPathname()

		const backgroundCanvas = document.getElementById("backgroundPongCanvas");
		const interactiveCanvas = document.getElementById("pongCanvas");
		const canvasContainer = document.getElementById("canvasContainer");
		const backgroundCtx = backgroundCanvas.getContext("2d");
		const interactiveCtx = interactiveCanvas.getContext("2d");

		//colors for background and objects

		const backgroundColor = 'black';
		const decorColor = '#28df28';

		//default values of the gamespace
		const defaultPaddleHeight = 50;
		const defaultPaddleWidth = 10;
		const defaultBallRadius = 5;
		const fieldHeight = 500;
		const fieldWidth = 800;
		const defaultFontSize = 32;

		//scaled values variables (initialized here, modified upon window resize)
		let paddleHeight = defaultPaddleHeight;
		let paddleWidth = 10;
		let leftPaddleX = 0;
		let rightPaddleX = interactiveCanvas.width - paddleWidth;
		let scoreHeight = 550;
		let relativeHeight = 1;
		let relativeWidth = 1;
		let ballRadius = defaultBallRadius;
		let fontSize = defaultFontSize + 'px';

		//global variable for stroing the gamestate
		let gameState = {
			"score1": 0,
			"score2": 0,
			"paddle1": (fieldHeight - paddleHeight) / 2,
			"paddle2": (fieldHeight - paddleHeight) / 2,
			"ball": [
				fieldWidth / 2,
				fieldHeight / 2
			]
		};

		//key delay
		const repeatDelay = 16; //delay in millis
		let activeKey = null; //tracks the currently active key (either 'w' or 's')
		let keyPressed = {};  //tracks which keys are pressed
		let keyInterval = null; //stores the interval for the active key

		const chatSocket = new WebSocket(
			'ws://'
			+ window.location.host
			+ '/ws/game/'
			+ window.location.pathname.split('/').filter(Boolean).pop()
			+ '/'
		);
		
		chatSocket.onopen = function(e) {
			console.log("Connection opened");
		}

		chatSocket.onmessage = function(e) {
			decodeState(e.data);
			removeElems(gameState)
			renderPartialGame(gameState);
		}

		chatSocket.onclose = function(e) {
			console.error('Connection closed');
		}

		chatSocket.onerror = function(error) {
			console.log("WebSocket error: ", error);
		}

		function startSendingKey(key) {
			if (keyInterval) {
				clearInterval(keyInterval);
			}
			keyInterval = setInterval(() => {
				chatSocket.send(key);
			}, repeatDelay);
		}

		//this will detect when the window loses focus, clearing intervals and keypresses.
		window.addEventListener('blur', function() {
			if (keyInterval)
				clearInterval(keyInterval);
			keyInterval = null;
			activeKey = null;
			keyPressed['w'] = false;
			keyPressed['s'] = false;
		});

		document.addEventListener('keyup', function(event) {
			const key = event.key;

			if (key === 'w' || key === 's') {
				keyPressed[key] = false;
				clearInterval(keyInterval);
				keyInterval = null;
				activeKey = null;

				//check if the other key is still pressed, and start sending its keylogs
				const otherKey = key === 'w' ? 's' : 'w';
				if (keyPressed[otherKey]) {
					activeKey = otherKey;
					chatSocket.send(otherKey);
					startSendingKey(otherKey);
				}
			}
		});

		document.addEventListener('keydown', (event) => {
			const key = event.key;

			if ((key === 'w' || key === 's') && !keyPressed[key]) {
				keyPressed[key] = true;

				if (activeKey === null) { //start sending keylogs if no other key is active
					activeKey = key;
					chatSocket.send(key);
					startSendingKey(key);
				} else if (activeKey !== key) { //stop sending keylogs if another key is pressed
					clearInterval(keyInterval);
					keyInterval = null;
				}
			}
		});

		function decodeState(rawState) {
			values = rawState.split(' ');
			gameState = {
				"score1": parseInt(values[0], 10),
				"score2": parseInt(values[1], 10),
				"paddle1": parseInt(values[2], 10),
				"paddle2": parseInt(values[3], 10),
				"ball": [
					values[4],
					values[5]
				]
			};
		}

		function drawPaddle1(paddle) {
			const paddleY = paddle * relativeHeight;
			interactiveCtx.fillRect(leftPaddleX, paddleY, paddleWidth, paddleHeight);
		}

		function drawPaddle2(paddle) {
			const paddleY = paddle * relativeHeight;
			interactiveCtx.fillRect(rightPaddleX, paddleY, paddleWidth, paddleHeight);
		}
		
		function drawBall(ball) {
			interactiveCtx.beginPath();
			const ballPosX = paddleWidth + (ball[0] * relativeWidth);
			const ballPosY = ball[1] * relativeHeight;
			interactiveCtx.arc(ballPosX, ballPosY, ballRadius, 0, 2 * Math.PI);
			interactiveCtx.fill();
			interactiveCtx.closePath();
		}

		function drawScore1(score1) {
			interactiveCtx.font = fontSize + ' Handjet';
			interactiveCtx.fillText(score1, interactiveCanvas.width / 4, scoreHeight);
		}

		function drawScore2(score2) {
			interactiveCtx.font = fontSize + ' Handjet';
			interactiveCtx.fillText(score2, 3 * interactiveCanvas.width / 4, scoreHeight);
		}

		function drawField() {
			//draw goal lines
			backgroundCtx.fillRect(paddleWidth, 0, 1, 5 * backgroundCanvas.height / 6);
			backgroundCtx.fillRect(rightPaddleX, 0, 1, 5 * backgroundCanvas.height / 6);

			//draw middle line
			backgroundCtx.fillRect(backgroundCanvas.width / 2, 0, 1, 5 * backgroundCanvas.height / 6);

			//draw top and bottom limits
			backgroundCtx.fillRect(0, 0, backgroundCanvas.width, 1);
			backgroundCtx.fillRect(0, 5 * backgroundCanvas.height / 6, backgroundCanvas.width, 1);
		}

		function renderGame(gameState) {
			backgroundCtx.fillStyle = backgroundColor;
			backgroundCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
			
			backgroundCtx.fillStyle = decorColor;
			drawField();
			renderPartialGame(gameState)
		}

		function removeElems(gameState) {
			interactiveCtx.clearRect(0, 0, interactiveCanvas.width, interactiveCanvas.height);
		}

		function renderPartialGame(gameState) {
			interactiveCtx.fillStyle = decorColor;
			drawPaddle1(gameState.paddle1);
			drawPaddle2(gameState.paddle2);
			drawBall(gameState.ball);
			drawScore1(gameState.score1);
			drawScore2(gameState.score2);
		}

		function resizeCanvas() {
			const navHeight = document.getElementById("navbar").clientHeight;
			console.log(navHeight);
			const windowAspectRatio = window.innerWidth / (window.innerHeight - navHeight);
			const canvasAspectRatio = 9 / 6;
			let canvasWidth, canvasHeight;

			if (windowAspectRatio > canvasAspectRatio) { // window is wider than the canvas ratio
				canvasHeight = window.innerHeight - navHeight;
				canvasWidth = canvasHeight * canvasAspectRatio;
			} else { // window is taller than the canvas ratio
				canvasWidth = window.innerWidth;
				canvasHeight = canvasWidth / canvasAspectRatio - navHeight;
			}

			canvasContainer.style.width = canvasWidth + 'px';
			canvasContainer.style.height = canvasHeight + 'px';

			interactiveCanvas.width = canvasWidth;
			interactiveCanvas.height = canvasHeight;
			backgroundCanvas.width = canvasWidth;
			backgroundCanvas.height = canvasHeight;

			relativeWidth = (interactiveCanvas.width - (2 * paddleWidth)) / fieldWidth;
			relativeHeight = (5 * interactiveCanvas.height / 6) / fieldHeight;
			scoreHeight = 5.5 * canvasHeight / 6;
			paddleWidth =  defaultPaddleWidth * relativeWidth;
			relativeWidth = (interactiveCanvas.width - (2 * paddleWidth)) / fieldWidth;
			rightPaddleX = interactiveCanvas.width - paddleWidth;
			ballRadius = defaultBallRadius * relativeHeight;
			paddleHeight = defaultPaddleHeight * relativeHeight;
			fontSize = (defaultFontSize * relativeHeight) + 'px';

			//redraw content after resizing
			renderGame(gameState)
		}

		window.addEventListener('resize', resizeCanvas);
		resizeCanvas();
	}
	start()

</script>